package kyr.parser;

import java.util.*;
import java_cup.runtime.*;

import kyr.ast.*;
import kyr.symtable.*;
import kyr.ast.expressions.*;
import kyr.ast.statements.*;
import kyr.ast.declarations.*;
import kyr.exceptions.*;


action code {: :};

parser code {:
    public void report_error(String message, Object info) {
        if (info instanceof Symbol) {
            Symbol sym = (Symbol) info;
            String tokenText = sym.value != null ? sym.value.toString() : "<empty>";
            int line = sym.left;
            int col  = sym.right;
            throw new SyntaxError("line " + line + ", col " + col + ": " + message + " (token: " + tokenText  +")");
        } else {
            throw new SyntaxError(message);
        }
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }
:};

/* ------------Declaration of Terminals and Non Terminals Section----------- */

/* Terminals (tokens returned by the scanner).  */
terminal Symbol BEGIN, END, SEMICOLON, PRINT, VARIABLES_KW, INTEGER_KW, BOOLEAN_KW, ASSIGN_OP, COMMA;

/* control statement keywords */
terminal Symbol IF_KW, THEN_KW, ELSE_KW, ENDIF_KW, REPEAT_KW, UNTIL_KW;

/* Parentheses */
terminal Symbol LPAREN, RPAREN;

/* Logics operators */
terminal Symbol AND_OP, OR_OP, NOT_OP;

/* comparators operators */
terminal Symbol EQ_OP, NEQ_OP, LT_OP, LE_OP, GT_OP, GE_OP;

/* Arithmetics operators */
terminal Symbol PLUS_OP, MINUS_OP, TIMES_OP, DIV_OP, MOD_OP;

/* mimus unary operator */
terminal Symbol UMINUS;

terminal String INTEGER, STRING, BOOLEAN, IDENTIFIER;

/* Non terminals used in the grammar section.  */

non terminal ASTNode PROG;
non terminal Sequence SEQ_NE;    // non-empty sequence of statements
non terminal Sequence SEQUENCE;  // possibly empty sequence of statements
non terminal Statement STATEMENT;
non terminal Expression EXP;
non terminal Type TYPE;
non terminal VariableDeclaration VAR_DECL;
non terminal Declaration DECLARATION;
non terminal Declaration DECLARATION_NE;

/* Priority order  */
precedence left OR_OP;
precedence left AND_OP;
precedence left EQ_OP, NEQ_OP;
precedence left LT_OP, LE_OP, GT_OP, GE_OP;
precedence left PLUS_OP, MINUS_OP;
precedence left TIMES_OP, DIV_OP, MOD_OP;
precedence right NOT_OP, UMINUS;  // Unary


/* ----------------------------Grammar Section-------------------- */

start with PROG;


PROG      ::=   VARIABLES_KW DECLARATION:decl BEGIN SEQUENCE:li END
                {: RESULT = new Program(decl, li); :}
           |
                BEGIN SEQUENCE:li END
                {: RESULT = new Program(li); :}
                 ;

DECLARATION
    ::= DECLARATION_NE:d {: RESULT = d; :}
    | /* empty */
      {: RESULT = new Declaration(-1); :}
    ;

DECLARATION_NE
    ::= DECLARATION_NE:d VAR_DECL:v
       {: SymbolTable.getInstance().add(v) ;
        d.add(v);
        RESULT = d;
        :}
    | VAR_DECL:v
       {: Declaration d = new Declaration(vleft + 1);
          SymbolTable.getInstance().add(v) ;
          d.add(v);
          RESULT = d;
       :}
    ;


SEQUENCE  ::=   SEQ_NE:li {: RESULT = li; :}
        |
                {: RESULT = new Sequence(-1); :}
                ;

SEQ_NE    ::=   SEQ_NE:li  STATEMENT:i
                {: li.add(i); RESULT = li; :}
        |
                STATEMENT:i
                {: Sequence b = new Sequence(ileft + 1);
                   b.add(i);
                   RESULT = b; :}
                ;

STATEMENT ::=   PRINT EXP:e SEMICOLON
                {: RESULT = new Print(e, eleft + 1); :}
        |
                PRINT STRING:cc SEMICOLON
                {: StringConstant c = new StringConstant(cc, ccleft + 1);
                   SymbolTable.getInstance().add(c);
                   RESULT = new Print(c, ccleft + 1); :}
        |
                IDENTIFIER:id ASSIGN_OP EXP:e SEMICOLON
                {: RESULT = new Assignment(id.toString(), e, eleft+1); :}
                ;

EXP       ::=   INTEGER:c
                {: RESULT = new IntegerConstant(c, cleft + 1); :}
        |
                 BOOLEAN:b
                {: RESULT = new BooleanConstant(b, bleft + 1); :}

        |
                IDENTIFIER:id
                {: RESULT = new VariableReference(id, idleft + 1); :}

                /* Parentheses */
        |
                LPAREN EXP:e RPAREN
              {: RESULT = e; :}

              /* Unary Operator */
        |
                NOT_OP EXP:e
              {: RESULT = new UnaryExpression("non", e, eleft + 1); :}

        |
                MINUS_OP EXP:e
              {: RESULT = new UnaryExpression("-", e, eleft + 1); :}
              %prec UMINUS

              /* Arithmetics Operator*/
        |
               EXP:e1 PLUS_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, "+", e2, e1left + 1); :}

        |
               EXP:e1 MINUS_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, "-", e2, e1left + 1); :}

        |
               EXP:e1 TIMES_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, "*", e2, e1left + 1); :}

        |
               EXP:e1 DIV_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, "/", e2, e1left + 1); :}

        |
               EXP:e1 MOD_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, "%", e2, e1left + 1); :}

              /* Comparators Operators */
        |
               EXP:e1 LT_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, "<", e2, e1left + 1); :}

        |
               EXP:e1 LE_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, "<=", e2, e1left + 1); :}

        |
               EXP:e1 GT_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, ">", e2, e1left + 1); :}

        |        EXP:e1 GE_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, ">=", e2, e1left + 1); :}

        |
                 EXP:e1 EQ_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, "==", e2, e1left + 1); :}

        |
               EXP:e1 NEQ_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, "!=", e2, e1left + 1); :}

              /* Logics Operator */
        |
               EXP:e1 AND_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, "et", e2, e1left + 1); :}

        |
               EXP:e1 OR_OP EXP:e2
              {: RESULT = new BinaryExpression(e1, "ou", e2, e1left + 1); :}

              ;



VAR_DECL ::= TYPE:t IDENTIFIER:id
              {: RESULT = new VariableDeclaration(t, id, idleft + 1); :}
               ;


TYPE    ::=     INTEGER_KW
                {: RESULT = Type.INTEGER; :}
        |
                BOOLEAN_KW
                {: RESULT = Type.BOOLEAN; :}
                ;

