package kyr.parser;

import java.util.*;
import java_cup.runtime.*;

import kyr.ast.*;
import kyr.symtable.*;
import kyr.ast.expressions.*;
import kyr.ast.statements.*;
import kyr.ast.declarations.*;
import kyr.exceptions.*;


action code {: :};

parser code {:
    public void report_error(String message, Object info) {
        if (info instanceof Symbol) {
            Symbol sym = (Symbol) info;
            String tokenText = sym.value != null ? sym.value.toString() : "<empty>";
            int line = sym.left;
            int col  = sym.right;
            throw new SyntaxError("line " + line + ", col " + col + ": " + message + " (token: " + tokenText  +")");
        } else {
            throw new SyntaxError(message);
        }
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }
:};

/* ------------Declaration of Terminals and Non Terminals Section----------- */

/* Terminals (tokens returned by the scanner).  */

terminal Symbol BEGIN, END, SEMICOLON, PRINT, VARIABLES_KW, INTEGER_KW, BOOLEAN_KW, ASSIGN_OP;
terminal String INTEGER, STRING, BOOLEAN, IDENTIFIER;

/* Non terminals used in the grammar section.  */

non terminal ASTNode PROG;
non terminal Sequence SEQ_NE;    // non-empty sequence of statements
non terminal Sequence SEQUENCE;  // possibly empty sequence of statements
non terminal Statement STATEMENT;
non terminal Expression EXP;
non terminal Type TYPE;
non terminal VariableDeclaration VAR_DECL;
non terminal Declaration DECLARATION;
non terminal Declaration DECLARATION_NE;


/* ----------------------------Grammar Section-------------------- */

start with PROG;




PROG      ::=   VARIABLES_KW DECLARATION:decl BEGIN SEQUENCE:li END
                {: RESULT = new Program(decl, li); :}
           |
                BEGIN SEQUENCE:li END
                {: RESULT = new Program(li); :}
                 ;

DECLARATION
    ::= DECLARATION_NE:d {: RESULT = d; :}
    | /* empty */
      {: RESULT = new Declaration(-1); :}
    ;

DECLARATION_NE
    ::= DECLARATION_NE:d VAR_DECL:v
       {: SymbolTable.getInstance().add(v) ;
        d.add(v);
        RESULT = d;
        :}
    | VAR_DECL:v
       {: Declaration d = new Declaration(vleft + 1);
          SymbolTable.getInstance().add(v) ;
          d.add(v);
          RESULT = d;
       :}
    ;


SEQUENCE  ::=   SEQ_NE:li {: RESULT = li; :}
        |
                {: RESULT = new Sequence(-1); :}
                ;

SEQ_NE    ::=   SEQ_NE:li  STATEMENT:i
                {: li.add(i); RESULT = li; :}
        |
                STATEMENT:i
                {: Sequence b = new Sequence(ileft + 1);
                   b.add(i);
                   RESULT = b; :}
                ;

STATEMENT ::=   PRINT EXP:e SEMICOLON
                {: RESULT = new Print(e, eleft + 1); :}
        |
                PRINT STRING:cc SEMICOLON
                {: StringConstant c = new StringConstant(cc, ccleft + 1);
                   SymbolTable.getInstance().add(c);
                   RESULT = new Print(c, ccleft + 1); :}
        |
                IDENTIFIER:id ASSIGN_OP EXP:e SEMICOLON
                {: RESULT = new Assignment(id.toString(), e, eleft+1); :}
                ;

EXP       ::=   INTEGER:c
                {: RESULT = new IntegerConstant(c, cleft + 1); :}
        |
                 BOOLEAN:b
                {: RESULT = new BooleanConstant(b, bleft + 1); :}

        |
                IDENTIFIER:id
                {: RESULT = new VariableReference(id, idleft); :}
                ;



VAR_DECL ::= TYPE:t IDENTIFIER:id
              {: RESULT = new VariableDeclaration(t, id, idleft + 1); :}
               ;


TYPE    ::=     INTEGER_KW
                {: RESULT = Type.INTEGER; :}
        |
                BOOLEAN_KW
                {: RESULT = Type.BOOLEAN; :}
                ;

